<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hypergraph Visualization</title>
    <!-- <script src="https://unpkg.com/@antv/g6@5/dist/g6.min.js"></script> -->
    <!-- Using modified g6 -->
    <!-- <script src="http://hub.dappwind.com/static/g6.min.js"></script> -->
    <script src="./g6.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <script src="./data.js"></script>
    <style type="text/tailwindcss">
      @theme {
        --color-primary-50: #faf5ff;
        --color-primary-500: #8b5cf6;
        --color-primary-600: #7c3aed;
        --color-primary-700: #6d28d9;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useRef } = React;
      const { Graph } = window.G6;

      // API base path
      // const API_BASE = window.location.origin;
      // dev mode
      const API_BASE = "http://localhost:8080";

      // Configuration constants
      const COLORS = [
        "#F6BD16",
        "#00C9C9",
        "#F08F56",
        "#D580FF",
        "#FF3D00",
        "#16f69c",
        "#004ac9",
        "#f056d1",
        "#a680ff",
        "#c8ff00",
      ];

      // 6 predefined colors, cycled for different entity types
      const ENTITY_TYPE_COLORS_PALETTE = [
        "#00C9C9",
        "#a68fff",
        "#F08F56",
        "#0d7c4f",
        "#004ac9",
        "#f056d1",
      ];

      const DEFAULT_NODE_COLOR = "#8b5cf6";

      // Dynamically generate entity type color mapping
      const generateEntityTypeColors = (vertices) => {
        const entityTypes = [
          ...new Set(vertices.map((v) => v.entity_type).filter(Boolean)),
        ];
        const colorMap = {};

        entityTypes.forEach((entityType, index) => {
          colorMap[entityType] =
            ENTITY_TYPE_COLORS_PALETTE[
              index % ENTITY_TYPE_COLORS_PALETTE.length
            ];
        });

        return colorMap;
      };
      const LAYOUT_THRESHOLD = 100;
      const EDGE_SEPARATOR = "|#|";

      // Utility functions
      const createBubbleStyle = (baseColor) => ({
        fill: baseColor,
        stroke: baseColor,
        maxRoutingIterations: 100,
        maxMarchingIterations: 20,
        pixelGroup: 4,
        edgeR0: 10,
        edgeR1: 60,
        nodeR0: 1,
        nodeR1: 5,
        morphBuffer: 10,
        threshold: 4,
        memberInfluenceFactor: 1,
        edgeInfluenceFactor: 4,
        nonMemberInfluenceFactor: -0.8,
        virtualEdges: true,
      });

      const getNodeColor = (node, selectedVertex, entityTypeColors) => {
        if (node.id === selectedVertex) return "#6d28d9";
        return entityTypeColors[node.entity_type] || DEFAULT_NODE_COLOR;
      };

      const formatDescription = (description) => {
        if (!description) return "";
        return description.split("<SEP>").join(" ");
      };

      // API call functions
      const fetchDatabaseInfo = async () => {
        if (typeof datas !== "undefined") {
          return Promise.resolve(datas.database);
        }
        const response = await fetch(`${API_BASE}/api/database/info`);
        return await response.json();
      };

      const fetchVertices = async (
        page,
        pageSize,
        search,
        sortBy,
        sortOrder
      ) => {
        if (typeof datas !== "undefined") {
          const toLower = (v) => (v ?? "").toString().toLowerCase();
          let list = Array.isArray(datas.vertices) ? datas.vertices : [];

          if (search) {
            const q = toLower(search);
            list = list.filter(
              (v) =>
                toLower(v.id).includes(q) ||
                toLower(v.entity_type).includes(q) ||
                toLower(v.description).includes(q)
            );
          }

          if (sortBy === "degree") {
            list.sort((a, b) =>
              sortOrder === "asc"
                ? (a.degree || 0) - (b.degree || 0)
                : (b.degree || 0) - (a.degree || 0)
            );
          } else if (sortBy === "id") {
            list.sort((a, b) => {
              const cmp = String(a.id).localeCompare(String(b.id));
              return sortOrder === "asc" ? cmp : -cmp;
            });
          }

          const total = list.length;
          const total_pages = Math.max(1, Math.ceil(total / pageSize));
          const cur = Math.min(Math.max(1, page), total_pages);
          const start = (cur - 1) * pageSize;
          const data = list.slice(start, start + pageSize);
          return Promise.resolve({
            data,
            pagination: { page: cur, page_size: pageSize, total, total_pages },
          });
        }
        const params = new URLSearchParams({
          page: page.toString(),
          page_size: pageSize.toString(),
          search: search || "",
          sort_by: sortBy,
          sort_order: sortOrder,
        });
        const response = await fetch(`${API_BASE}/api/vertices?${params}`);
        return await response.json();
      };

      const fetchGraphData = async (vertexId) => {
        if (typeof datas !== "undefined") {
          const entry = datas.graphs[vertexId];
          if (entry && entry.vertices && entry.edges) {
            return Promise.resolve({
              vertices: entry.vertices,
              edges: entry.edges,
            });
          }
          return Promise.resolve({ vertices: {}, edges: {} });
        }
        const params = new URLSearchParams({ vertex_id: vertexId });
        const response = await fetch(`${API_BASE}/api/graph?${params}`);
        return await response.json();
      };

      function HypergraphViewer() {
        const containerRef = useRef(null);
        const graphRef = useRef(null);
        const searchTimeoutRef = useRef(null);

        const [databaseInfo, setDatabaseInfo] = useState({
          vertices: 0,
          edges: 0,
        });
        const [vertices, setVertices] = useState([]);
        const [pagination, setPagination] = useState({
          page: 1,
          page_size: 50,
          total: 0,
          total_pages: 0,
        });
        const [selectedVertex, setSelectedVertex] = useState("");
        const [graphData, setGraphData] = useState(null);
        const [loading, setLoading] = useState(false);
        const [loadingVertices, setLoadingVertices] = useState(false);
        const [error, setError] = useState("");
        const [searchTerm, setSearchTerm] = useState("");
        const [sortBy, setSortBy] = useState("degree");
        const [sortOrder, setSortOrder] = useState("desc");
        const [visualizationMode, setVisualizationMode] = useState("hyper");
        const [hoverHyperedge, setHoverHyperedge] = useState(null);
        const [hoverNode, setHoverNode] = useState(null);

        // Generate entity type color mapping
        const entityTypeColors = useMemo(() => {
          return generateEntityTypeColors(vertices);
        }, [vertices]);

        // Load database info
        useEffect(() => {
          fetchDatabaseInfo().then(setDatabaseInfo).catch(console.error);
        }, []);

        // Load vertices list
        const loadVertices = async (page, search, sortBy, sortOrder) => {
          setLoadingVertices(true);
          try {
            const result = await fetchVertices(
              page,
              pagination.page_size,
              search,
              sortBy,
              sortOrder
            );
            setVertices(result.data);
            setPagination(result.pagination);

            // If no vertex selected and data exists, select the first one
            if (result.data.length > 0) {
              setSelectedVertex(result.data[0].id);
            }
          } catch (err) {
            console.error("Failed to load vertices:", err);
          } finally {
            setLoadingVertices(false);
          }
        };

        // Initial load of vertices
        useEffect(() => {
          loadVertices(1, "", sortBy, sortOrder);
        }, []);

        // Search debounce
        useEffect(() => {
          if (searchTimeoutRef.current) {
            clearTimeout(searchTimeoutRef.current);
          }

          searchTimeoutRef.current = setTimeout(() => {
            loadVertices(1, searchTerm, sortBy, sortOrder);
          }, 300);

          return () => {
            if (searchTimeoutRef.current) {
              clearTimeout(searchTimeoutRef.current);
            }
          };
        }, [searchTerm]);

        // Reload when sort changes
        useEffect(() => {
          if (vertices.length > 0) {
            loadVertices(pagination.page, searchTerm, sortBy, sortOrder);
          }
        }, [sortBy, sortOrder]);

        // Load when page changes
        const handlePageChange = (newPage) => {
          loadVertices(newPage, searchTerm, sortBy, sortOrder);
        };

        // Load graph data
        useEffect(() => {
          if (selectedVertex) {
            setLoading(true);
            setError("");

            fetchGraphData(selectedVertex)
              .then((data) => {
                if (data.error) {
                  setError(data.error);
                } else {
                  setGraphData(data);
                }
              })
              .catch((err) => {
                setError("Failed to load graph data");
                console.error(err);
              })
              .finally(() => {
                setLoading(false);
              });
          }
        }, [selectedVertex]);

        const excludedKeys = new Set([
          "id",
          "label",
          "style",
          "data",
          "weight",
          "source_id",
        ]);

        // Convert data to G6 Graph format
        const graphDataFormatted = useMemo(() => {
          if (!graphData) return null;

          const hyperData = {
            nodes: Object.entries(graphData.vertices).map(([key, value]) => ({
              id: key,
              label: key,
              ...value,
            })),
            edges: [],
            hyperEdges: [],
          };
          const plugins = [];
          const edgeEntries = Object.entries(graphData.edges);

          if (visualizationMode === "graph") {
            // Graph mode: only show dimension 2 ball-and-stick diagram
            const edgeSet = new Set();

            edgeEntries.forEach(([key, edge]) => {
              const nodes = key.split(EDGE_SEPARATOR);
              if (nodes.length !== 2) return;

              const [a, b] = nodes;
              const edgeId = a < b ? `${a}-${b}` : `${b}-${a}`;

              if (!edgeSet.has(edgeId)) {
                edgeSet.add(edgeId);
                hyperData.edges.push({
                  id: edgeId,
                  source: a,
                  target: b,
                  ...edge,
                });
              }
            });

            // Filter unconnected nodes
            const connectedNodes = new Set();
            hyperData.edges.forEach((edge) => {
              connectedNodes.add(edge.source);
              connectedNodes.add(edge.target);
            });
            hyperData.nodes = hyperData.nodes.filter((node) =>
              connectedNodes.has(node.id)
            );
          } else {
            // Hyper mode: render 2-node entries as normal edges, others as bubble-sets
            const edgeSet = new Set();
            edgeEntries.forEach(([key, edge], i) => {
              const nodes = key.split(EDGE_SEPARATOR);

              if (nodes.length === 2) {
                const [a, b] = nodes;
                const edgeId = a < b ? `${a}-${b}` : `${b}-${a}`;
                if (!edgeSet.has(edgeId)) {
                  edgeSet.add(edgeId);
                  hyperData.edges.push({
                    id: edgeId,
                    source: a,
                    target: b,
                    ...edge,
                  });
                }
                return;
              }

              plugins.push({
                key: `bubble-sets-${key}`,
                type: "bubble-sets",
                members: nodes,
                weight: edge.weight || nodes.length,
                description: edge.description || edge.summary || "",
                edge: edge,
                ...createBubbleStyle(COLORS[i % COLORS.length]),
              });

              hyperData.hyperEdges.push({
                id: key,
                ...edge,
                members: nodes,
              });
            });

            // Assign cluster by hyperEdges for layout grouping
            // Pick the heaviest hyperedge containing the node as its primary cluster
            const nodeIdToCandidateClusters = new Map();
            hyperData.hyperEdges.forEach((he) => {
              const weight =
                he.weight ||
                (Array.isArray(he.members) ? he.members.length : 1);
              (he.members || []).forEach((m) => {
                const list = nodeIdToCandidateClusters.get(m) || [];
                list.push({ id: he.id, weight });
                nodeIdToCandidateClusters.set(m, list);
              });
            });
            hyperData.nodes = hyperData.nodes.map((n) => {
              const candidates = nodeIdToCandidateClusters.get(n.id) || [];
              if (candidates.length === 0) return n;
              const primary = candidates.reduce((best, cur) =>
                cur.weight > best.weight ? cur : best
              );
              return { ...n, cluster: primary.id };
            });
          }

          // Add tooltip plugin

          plugins.push({
            type: "tooltip",
            getContent: (e, items) => {
              return items
                .map((item) => {
                  let result = `<h3><strong>${
                    item.entity_name || item.id
                  }</strong></h3>`;
                  // Display all remaining properties
                  Object.entries(item).forEach(([key, value]) => {
                    if (!excludedKeys.has(key)) {
                      result += `<p><strong>${key}:</strong> ${value}</p>`;
                    }
                  });
                  return result;
                })
                .join("");
            },
          });

          const isGraph = visualizationMode === "graph";

          return {
            data: hyperData,
            plugins: isGraph ? [plugins[plugins.length - 1]] : plugins,
            node: {
              palette: { field: "cluster" },
              style: {
                size: hyperData.nodes.length > LAYOUT_THRESHOLD ? 15 : 20,
                labelText: (d) => d.id,
                fill: (d) => getNodeColor(d, selectedVertex, entityTypeColors),
              },
            },
            edge: {
              style: {
                size: isGraph ? 3 : 2,
                stroke: "#a68fff",
                lineWidth: 1,
              },
            },
            layout: {
              type:
                hyperData.nodes.length > LAYOUT_THRESHOLD ? "force" : "force",
              clustering: !isGraph,
              preventOverlap: true,
              nodeClusterBy: isGraph ? undefined : "cluster",
              gravity: 50,
              linkDistance: 50,
            },
            autoFit: "center",
          };
        }, [graphData, selectedVertex, visualizationMode, entityTypeColors]);

        // Initialize graph
        useEffect(() => {
          if (!graphDataFormatted || !containerRef.current) return;

          // Destroy previous graph instance and clear canvas
          if (graphRef.current && !graphRef.current.destroyed) {
            graphRef.current.clear();
            if (containerRef.current) {
              containerRef.current.innerHTML = "";
            }
          }

          const graph = new Graph({
            container: containerRef.current,
            width: containerRef.current.offsetWidth,
            height: containerRef.current.offsetHeight || 800,
            data: graphDataFormatted.data,
            behaviors: ["zoom-canvas", "drag-canvas", "drag-element"],
            autoFit: "center",
            animate: false,
            node: graphDataFormatted.node,
            edge: graphDataFormatted.edge,
            layout: graphDataFormatted.layout,
            plugins: graphDataFormatted.plugins,
          });

          graphRef.current = graph;
          graphRef.current.render();

          graph.on("pointermove", (e) => {
            if (e.targetType === "bubble-sets") {
              const target = e.target.options;
              const newHyperedge = {
                ...target.edge,
                members: Array.isArray(target.members) ? target.members : [],
              };
              setHoverHyperedge((prev) => {
                if (
                  !prev ||
                  prev.keywords !== newHyperedge.keywords ||
                  prev.summary !== newHyperedge.summary ||
                  prev.weight !== newHyperedge.weight ||
                  JSON.stringify(prev.members) !==
                    JSON.stringify(newHyperedge.members)
                ) {
                  return newHyperedge;
                }
                return prev;
              });
            }
            if (e.targetType === "node") {
              const target = graphDataFormatted.data.nodes.find(
                (node) => node.id === e.target.id
              );
              setHoverNode((prev) => {
                if (!prev || prev.id !== target?.id) {
                  return target;
                }
                return prev;
              });
            }
          });

          // Add window resize listener
          const handleResize = () => {
            if (graphRef.current && containerRef.current) {
              graphRef.current.setSize(
                containerRef.current.offsetWidth,
                containerRef.current.offsetHeight
              );
            }
          };

          window.addEventListener("resize", handleResize);

          return () => {
            window.removeEventListener("resize", handleResize);
            if (graphRef.current && !graphRef.current.destroyed) {
              graphRef.current.clear();
            }
            if (containerRef.current) {
              containerRef.current.innerHTML = "";
            }
            setHoverHyperedge(null);
          };
        }, [graphDataFormatted, visualizationMode]);

        // Select the "largest" node and hyperedges by default
        useEffect(() => {
          if (!graphDataFormatted) return;

          const nodes = graphDataFormatted.data.nodes;
          if (!hoverNode && nodes.length > 0) {
            const nodeWithMax = nodes.reduce((best, cur) =>
              (cur.degree || 0) > (best.degree || 0) ? cur : best
            );
            setHoverNode(nodeWithMax);
          }

          if (visualizationMode === "hyper") {
            const hyperEdges = graphDataFormatted.data.hyperEdges;
            if (!hoverHyperedge && hyperEdges.length > 0) {
              const getWeight = (edge) =>
                edge.weight || edge.members?.length || 0;
              const hyperWithMax = hyperEdges.reduce((best, cur) =>
                getWeight(cur) > getWeight(best) ? cur : best
              );

              setHoverHyperedge({
                keywords: hyperWithMax.keywords || "",
                description:
                  hyperWithMax.description || hyperWithMax.summary || "",
                members: hyperWithMax.members || [],
                weight: getWeight(hyperWithMax),
              });
            }
          }
        }, [graphDataFormatted, visualizationMode, hoverNode, hoverHyperedge]);

        return (
          <div className="flex h-screen bg-gradient-to-br from-gray-50 to-gray-100">
            <div className="w-80 h-screen overflow-hidden bg-white/95 backdrop-blur-sm border-r border-gray-200/50 p-6 shadow-xl shrink-0 flex flex-col">
              <h2 className="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                Hypergraph-DB
              </h2>

              <div className="text-lg font-bold text-gray-800 mb-3 pb-2 border-b-2 border-primary-500">
                Database Information
              </div>
              <div className="p-2 rounded-xl mb-6 text-sm border">
                <div className="flex justify-between items-center mb-2">
                  <span className="font-semibold text-gray-700">Vertices:</span>
                  <span className="font-bold text-primary-600">
                    {databaseInfo.vertices}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="font-semibold text-gray-700">
                    Hyperedges:
                  </span>
                  <span className="font-bold text-primary-600">
                    {databaseInfo.edges}
                  </span>
                </div>
              </div>

              <div className="text-lg font-bold text-gray-800 mb-3 pb-2 border-b-2 border-primary-500">
                Search & Vertex List
              </div>

              {/* Search and Sort */}
              <div className="mb-4">
                <div className="relative mb-2">
                  <input
                    type="text"
                    placeholder="Search vertex ID, type or description..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full px-4 py-2 pl-10 pr-4 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all duration-200"
                  />
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <svg
                      className="h-4 w-4 text-gray-400"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                      />
                    </svg>
                  </div>
                  {searchTerm && (
                    <button
                      onClick={() => setSearchTerm("")}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
                    >
                      <svg
                        className="h-4 w-4"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M6 18L18 6M6 6l12 12"
                        />
                      </svg>
                    </button>
                  )}
                </div>

                {/* Sort Selection */}
                {/*<div className="flex gap-2 text-xs text-gray-600">
                  <select
                    value={sortBy}
                    onChange={(e) => setSortBy(e.target.value)}
                    className="flex-1 px-2 py-1 border border-gray-300 rounded"
                  >
                    <option value="degree">By Degree</option>
                    <option value="id">By ID</option>
                  </select>
                  <select
                    value={sortOrder}
                    onChange={(e) => setSortOrder(e.target.value)}
                    className="flex-1 px-2 py-1 border border-gray-300 rounded"
                  >
                    <option value="desc">Descending</option>
                    <option value="asc">Ascending</option>
                  </select>
                </div>*/}

                <div className="mt-2 text-sm text-gray-600">
                  Found {pagination.total} results
                </div>
              </div>

              {/* Vertices List */}
              <div className="flex-1 overflow-y-scroll hide-scrollbar border border-gray-200 rounded-xl bg-white shadow-inner">
                {loadingVertices ? (
                  <div className="p-4 text-center text-gray-500">
                    Loading vertices...
                  </div>
                ) : vertices.length === 0 ? (
                  <div className="p-4 text-center text-gray-500">
                    No matching vertices found
                  </div>
                ) : (
                  vertices.map((vertex) => {
                    const isSelected = selectedVertex === vertex.id;

                    return (
                      <div
                        key={vertex.id}
                        className={`p-2 border-b border-gray-100 cursor-pointer transition-all duration-200 hover:bg-gray-50 hover:shadow-sm ${
                          isSelected
                            ? "bg-primary-50 border-l-4 border-l-primary-500 shadow-md"
                            : ""
                        }`}
                        onClick={() => setSelectedVertex(vertex.id)}
                      >
                        <div className="font-bold text-gray-800 mb-2 flex items-center">
                          {vertex.id}
                        </div>
                        <div className="text-sm text-gray-600 flex gap-2 items-center">
                          <div className="flex items-center">
                            <span className="font-medium">
                              {vertex.entity_type ? "Type" : "ID"}:
                            </span>
                            <span className="ml-2 px-2 py-1 bg-gray-100 rounded text-xs">
                              {vertex.entity_type || vertex.id}
                            </span>
                          </div>
                          <div className="flex items-center">
                            <span className="font-medium">Degree:</span>
                            <span className="ml-2 px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-semibold">
                              {vertex.degree}
                            </span>
                          </div>
                        </div>
                        {vertex.description && (
                          <div className="mt-2 text-xs text-gray-500 bg-gray-50 p-2 rounded">
                            {formatDescription(vertex.description)}
                          </div>
                        )}
                      </div>
                    );
                  })
                )}
              </div>

              {/* Pagination Controls */}
              {pagination.total_pages > 1 && (
                <div className="mt-4 flex items-center justify-between text-sm">
                  <button
                    onClick={() => handlePageChange(pagination.page - 1)}
                    disabled={pagination.page === 1}
                    className="px-3 py-1 bg-primary-500 text-white rounded disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-primary-600"
                  >
                    Previous
                  </button>
                  <span className="text-gray-600">
                    {pagination.page} / {pagination.total_pages}
                  </span>
                  <button
                    onClick={() => handlePageChange(pagination.page + 1)}
                    disabled={pagination.page === pagination.total_pages}
                    className="px-3 py-1 bg-primary-500 text-white rounded disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-primary-600"
                  >
                    Next
                  </button>
                </div>
              )}
            </div>

            <div className="flex-1 flex flex-col bg-white/10 backdrop-blur-sm">
              <div className="bg-white/95 p-4 border-b border-gray-200/50 flex justify-between items-center shadow-sm">
                <div className="flex items-center gap-4">
                  <h3 className="text-xl font-semibold text-gray-800 m-0">
                    {visualizationMode === "hyper" ? "Hypergraph" : "Graph"}{" "}
                    Visualization {selectedVertex && `- ${selectedVertex}`}
                  </h3>

                  {/* Visualization Mode Selector */}
                  <div className="flex items-center gap-2">
                    <span className="text-sm text-gray-600">Mode:</span>
                    <div className="flex space-x-1">
                      {["hyper", "graph"].map((mode) => (
                        <button
                          key={mode}
                          onClick={() => setVisualizationMode(mode)}
                          className={`px-3 py-1 text-xs rounded-full transition-all duration-200 ${
                            visualizationMode === mode
                              ? "bg-primary-500 text-white shadow-md"
                              : "bg-gray-100 text-gray-600 hover:bg-gray-200"
                          }`}
                        >
                          {mode === "hyper" ? "Hypergraph" : "Graph"}
                        </button>
                      ))}
                    </div>
                  </div>
                </div>

                {graphData && (
                  <div className="bg-white px-4 py-2 text-sm text-gray-600 rounded-lg shadow-sm border border-gray-200">
                    <span className="font-semibold">Vertices:</span>{" "}
                    {Object.keys(graphData.vertices).length} |
                    <span className="font-semibold ml-1">
                      {visualizationMode === "hyper" ? "Hyperedges:" : "Edges:"}
                    </span>{" "}
                    {visualizationMode === "hyper"
                      ? Object.keys(graphData.edges).length
                      : graphDataFormatted?.data?.edges?.length || 0}
                  </div>
                )}
              </div>

              <div className="flex-1 relative bg-white">
                {error && (
                  <div className="bg-red-50 text-red-700 p-4 m-4 rounded-lg border-l-4 border-red-500 shadow-sm">
                    <div className="flex items-center">
                      <span className="text-xl mr-2">⚠️</span>
                      <span className="font-medium">{error}</span>
                    </div>
                  </div>
                )}

                {loading && (
                  <div className="absolute inset-0 flex justify-center items-center bg-white/80 backdrop-blur-sm z-50 text-lg text-gray-600">
                    <div className="text-center">
                      <div className="text-2xl mb-4">🔄</div>
                      <div className="font-semibold">
                        Loading hypergraph data...
                      </div>
                      <div className="text-sm mt-2 text-gray-500">
                        This may take a few seconds
                      </div>
                    </div>
                  </div>
                )}

                <div className="flex h-[calc(100vh-71px)]">
                  <div
                    ref={containerRef}
                    className="w-full rounded-xl h-full"
                  />
                  {visualizationMode === "hyper" && (
                    <div className="shrink-0 w-72 h-full overflow-y-auto bg-white/95 backdrop-blur-sm border-l border-gray-200/50 p-3 shadow-xl overflow-y-auto">
                      <div className="text-lg font-bold text-gray-800 mb-3 pb-2 border-b-2 border-primary-500">
                        Hypergraph Detail
                      </div>
                      {hoverHyperedge && (
                        <div className="text-sm text-gray-700 space-y-3 border-b-2 border-primary-500 pb-6">
                          <div className="text-base font-semibold text-gray-900">
                            Hyperedge
                          </div>
                          {Object.entries(hoverHyperedge).map(
                            ([key, value]) => {
                              // Skip empty values
                              if (
                                !value ||
                                (Array.isArray(value) && value.length === 0) ||
                                excludedKeys.has(key)
                              ) {
                                return null;
                              }

                              // Special handling for keywords
                              if (
                                key === "keywords" &&
                                typeof value === "string"
                              ) {
                                return (
                                  <div key={key}>
                                    <span className="font-medium">
                                      keywords:
                                    </span>
                                    <div className="flex flex-wrap gap-2 mt-2">
                                      {value
                                        .split(/,|，|、|。|<SEP>/)
                                        .filter((k) => k.trim())
                                        .map((keyword, i) => (
                                          <span
                                            key={i}
                                            className="inline-block p-1 bg-primary-50 rounded text-xs"
                                          >
                                            {keyword.trim()}
                                          </span>
                                        ))}
                                    </div>
                                  </div>
                                );
                              }

                              // Special handling for members
                              if (Array.isArray(value)) {
                                return (
                                  <div key={key}>
                                    <div className="font-medium">
                                      {key} ({value.length}):
                                    </div>
                                    <div className="flex flex-wrap gap-2 mt-2">
                                      {value.map((member, i) => (
                                        <span
                                          key={i}
                                          className="p-1 bg-primary-50 rounded text-xs"
                                        >
                                          {member}
                                        </span>
                                      ))}
                                    </div>
                                  </div>
                                );
                              }

                              // Convert value to string for length check
                              const stringValue =
                                typeof value === "object"
                                  ? JSON.stringify(value, null, 2)
                                  : String(value).replace(/<SEP>/g, " | ");

                              // If value is less than 10 characters, display as tag
                              if (stringValue.length < 20) {
                                return (
                                  <div key={key}>
                                    <span className="font-medium">{key}:</span>
                                    <div className="mt-1">
                                      <span className="inline-block px-2 py-1 bg-gray-100 rounded text-xs">
                                        {stringValue}
                                      </span>
                                    </div>
                                  </div>
                                );
                              }

                              // Default handling for longer values
                              return (
                                <div key={key}>
                                  <span className="font-medium">{key}:</span>
                                  <div className="mt-1 text-gray-600 bg-gray-100 p-2 rounded text-xs">
                                    {stringValue}
                                  </div>
                                </div>
                              );
                            }
                          )}
                        </div>
                      )}
                      {hoverNode && (
                        <div className="text-sm text-gray-700 space-y-3 mt-4">
                          <div className="text-base font-semibold text-gray-900">
                            Node
                          </div>
                          {Object.entries(hoverNode).map(([key, value]) => {
                            // Skip empty values
                            if (
                              !value ||
                              (Array.isArray(value) && value.length === 0) ||
                              excludedKeys.has(key)
                            ) {
                              return null;
                            }

                            // Convert value to string for length check
                            const stringValue =
                              typeof value === "object"
                                ? JSON.stringify(value, null, 2)
                                : String(value).replace(/<SEP>/g, " | ");

                            // If value is less than 10 characters, display as tag
                            if (stringValue.length < 20) {
                              return (
                                <div key={key}>
                                  <span className="font-medium">{key}:</span>
                                  <div className="mt-1">
                                    <span className="inline-block px-2 py-1 bg-gray-100 rounded text-xs">
                                      {stringValue}
                                    </span>
                                  </div>
                                </div>
                              );
                            }

                            // Default handling for longer values
                            return (
                              <div key={key}>
                                <span className="font-medium">{key}:</span>
                                <div className="mt-1 text-gray-600 bg-gray-100 p-2 rounded text-xs">
                                  {stringValue}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.render(<HypergraphViewer />, document.getElementById("root"));
    </script>
  </body>
</html>
